
<!DOCTYPE html>
<html>
    <head>
        <!--Change the title-->
        <title>Combine Tasks</title>
        
        <!--jsPsych necessities start-->
        <script src="../static/js/jsPsych-6.0.1/jspsych.js"></script>
        <link href="../static/js/jsPsych-6.0.1/css/jspsych.css" rel="stylesheet" type="text/css"></link>
        <link href="../static/css/style.css" rel="stylesheet" type="text/css"></link>
        <!--jsPsych necessities end-->
        
        <!--jsPsych plugins start-->
        <script src="../static/js/jsPsych-6.0.1/plugins/jspsych-image-slider-response.js"></script>
        <script src="../static/js/jsPsych-6.0.1/plugins/jspsych-html-slider-response.js"></script>
        <script src="../static/js/jsPsych-6.0.1/plugins/jspsych-survey-multi-choice.js"></script>
        </script><script src="../static/js/jsPsych-6.0.1/plugins/jspsych-call-function.js"></script>
        <script src="../static/js/jsPsych-6.0.1/plugins/jspsych-instructions.js"></script>
        <script src="../static/js/jsPsych-6.0.1/plugins/jspsych-animation.js"></script>
        <script src="../static/js/jsPsych-6.0.1/plugins/jspsych-fullscreen.js"></script>
        <script src="../static/js/jsPsych-6.0.1/plugins/jspsych-html-button-response.js"></script>
        <script src="../static/js/jsPsych-6.0.2/plugins/jspsych-RDK3.js"></script>

        <!--jsPsych plugins end-->

        <!--PsiTurk inserts start-->
        <script src = "https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
        <script src="../static/lib/jquery-min.js" type="text/javascript"></script>
        <script src="../static/lib/underscore-min.js" type="text/javascript"> </script>
        <script src="../static/lib/backbone-min.js" type="text/javascript"> </script>
      <!--  <script src="../static/lib/d3.v3.min.js" type="text/javascript"> </script>-->
        <!-- These variables are necessary to implement psiTurk -->
        <script type="text/javascript">
            // These fields provided by the psiTurk Server
            var uniqueId = "{{ uniqueId }}"; // a unique string identifying the worker/task
            var adServerLoc = "{{ adServerLoc }}"; // the location of your ad (so you can send user back at end of experiment)
            var mode = "{{ mode }}"; // is this running live, sandbox, or in debug mode?
        </script>
        <!-- utils.js and psiturk.js provide the basic psiturk functionality -->
        <script src="../static/js/utils.js" type="text/javascript"></script>
        <!--<script src="../static/js/psiturk.js" type="text/javascript"></script>-->
        <!--PsiTurk inserts end-->
        <!--Include the faces for animation-->
        <script src="animationImages.js"></script>
    </head>
    <body>
     <body>   
		<!--<div class="loader" style="width=100%; height=100%"><br style="margin-bottom:3em;"/><p style="text-align: center;font-size: 5vw;">Loading...</p></div> 
		<!--<div id='jspsych-target' style='width:auto; height:auto; margin:auto;'></div> -->
		<!--><div id='stimuli-target' style='width:auto; height:auto; margin: 1% auto;'></div> -->
		<canvas id="myCanvas"></canvas>		
    </body>
	
    </body>
    <script>
    
        //Data switches
        var psiTurkIsOn = 0;   // 0: Test locally.  1: Test/Run on psiTurk
        var savingLocally = 1; // 0: Nothing.       1: Download CSV file
        var displayData = 0;   // 0: Nothing.       1: Display data on browser
        var savingToDatabase = 0;//Should be 1 when psiturkIsOn
        savingToDatabase = psiTurkIsOn ? 1 : savingToDatabase;//Safeguard to ensure that it saves to the database if psiturk is on
        
        var username = '';     // Username for psiturk server
        var tableName = '';    // MySQL Table Name 
        var folderName = '';   // Folder containing the experiment
        
        //Get the workerID, etc. if we are saving to Database
        if(savingToDatabase){
          var workerId = $_GET('workerId');
          var assignmentId = $_GET('assignmentId');
          var hitId = $_GET('hitId');
          
          console.log("workerId:");
          console.log(workerId);
          console.log("assignmentId:");
          console.log(assignmentId);
          console.log("hitId:");
          console.log(hitId);
        }
        
        
        // Load psiturk
        if (psiTurkIsOn){
          var psiturk = new PsiTurk(uniqueId, adServerLoc, mode);
        }
        
        
        ///////////////////////////////////////////////////////////////
        //-----------------Your code below this line-----------------//
                
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//----------------FACES CODE BELOW THIS LINE-----------------//
        //Parameters
        nFacesPerGender = 3; //How many faces to keep from each gender for the AFC trials
        nfacesTargets=2;
        nfacesNontargets=1; 
        
        //Global variables to be filled in by functions below
        var faces_phase2Array = []; //Array to hold all trials for phase 2 (mix of 2AFC and 3AFC)
        
        //Variable to keep track of whether the subject completed all phases
        var all_face_PhasesCompleted = false; //Set to true in on_finish of debrief block
        
        //Variable to keep track of whether the subject answered all the phase1 questions below 1s
        var subjectAnsweredAllFacePhase1Below1Second = true; //Changed in the on_finish function of the phase 1 questions
        
        //Wrappers for font sizes
        var wrapperStart = "<div style='font-size: 26px, position: absolute, top: 50%, left: 80%, text-align: center, font-family: Helvetica, sans-serif'>";
        var wrapperEnd = "</div>";
        
        
            //Set up the canvas and establish parameters for the lines (rects) you want to draw.
			var canvas = document.getElementById("myCanvas");
			var context = canvas.getContext("2d");    
			context.canvas.width  = window.innerWidth;
			context.canvas.height = window.innerHeight;
			var rectWidth = 4;
			var rectHeight = 30;
			var centerWidth = canvas.width / 2.0;
			var centerHeight = canvas.height / 2.0;
        
        
        
        //The array of male stimuli
        var female_stimuli = [
          // {path: '../static/images/female/AF01NES.JPG'},
//           {path: '../static/images/female/AF02NES.JPG'},
//           {path: '../static/images/female/AF03NES.JPG'},
//           {path: '../static/images/female/AF04NES.JPG'},
//           {path: '../static/images/female/AF05NES.JPG'},
//           {path: '../static/images/female/AF06NES.JPG'},
//           {path: '../static/images/female/AF07NES.JPG'},
//           {path: '../static/images/female/AF08NES.JPG'},
//           {path: '../static/images/female/AF09NES.JPG'},
//           {path: '../static/images/female/AF10NES.JPG'},
//           {path: '../static/images/female/AF11NES.JPG'},
//           {path: '../static/images/female/AF12NES.JPG'},
          {path: '../static/images/female/AF13NES.JPG'},
          {path: '../static/images/female/AF14NES.JPG'},
          {path: '../static/images/female/AF15NES.JPG'}
        ];

        //The array of female stumuli
        var male_stimuli = [
          // {path: '../static/images/male/AM01NES.JPG'},
//           {path: '../static/images/male/AM02NES.JPG'},
//           {path: '../static/images/male/AM03NES.JPG'},
//           {path: '../static/images/male/AM04NES.JPG'},
//           {path: '../static/images/male/AM05NES.JPG'},
//           {path: '../static/images/male/AM06NES.JPG'},
//           {path: '../static/images/male/AM07NES.JPG'},
//           {path: '../static/images/male/AM08NES.JPG'},
//           {path: '../static/images/male/AM09NES.JPG'},
//           {path: '../static/images/male/AM10NES.JPG'},
//           {path: '../static/images/male/AM11NES.JPG'},
//           {path: '../static/images/male/AM12NES.JPG'},
          {path: '../static/images/male/AM13NES.JPG'},
          {path: '../static/images/male/AM14NES.JPG'},
          {path: '../static/images/male/AM15NES.JPG'}
        ];
        
        //Extract the info of objects in the array
        female_stimuli = extractInfo(female_stimuli);
        male_stimuli = extractInfo(male_stimuli);
        
        //Make the instructions for phase 1
        var welcomeInstructions = makeWelcomeInstructions();
        
        //Make the first phase
        var faces_phase1 = make_faces_Phase1(); 
        
        //Prep for second phase (calc the rankings)
        var faces_prepForPhase2 = faces_makePrepForPhase2();//AFC2Array and AFC3Array are made here
        
        //Make the instructions for phase 2
        var faceInstructions1 = makeFaceInstructions1();
        
        //Trial counter to manage the loop node
        var faces_trialCounter = 0;
        
       // The AFC Trial to be looped
        var faces_AFCTrial = {
          type: 'html-button-response',
          stimulus: '',
          prompt: function(){
            return faces_phase2Array[faces_trialCounter].timeline[0].prompt;
          },
          choices: function(){
            return faces_phase2Array[faces_trialCounter].timeline[0].choices;
          },
          data: function(){
            return faces_phase2Array[faces_trialCounter].timeline[0].data;
          },
          on_finish: function(data){
            addfacesDataToTrial(data);
          }
        };
      //  The confidence Trial to be looped
        var faces_confidenceTrial = {
          type: 'html-slider-response',
          stimulus: '',
          labels: ['Extremely unconfident','Extremely confident'],
          start: 0,
          prompt: 'How confident are you in your choice?',
          data: function(){
            return faces_phase2Array[faces_trialCounter].timeline[1].data;
          },
          on_start: function(trial){
            confidence_on_start_function(trial);
          },
          on_finish: function(data){
            confidence_on_finish_function(data);
          }
        };
        
        //The loop node that loops through the phase2Array and play all the trials
        var faces_loopNode = {
          timeline: [faces_AFCTrial, faces_confidenceTrial],
          loop_function: function(data){//Return true to loop
            //If we have not reached the end of the array, then we 'loop' the trial
            if(faces_trialCounter < faces_phase2Array.length-1){
              faces_trialCounter++; //Increment the counter to go to the next trial
              return true; //Return true so that it loops
            }
            //Else we have reached the end of the array and should stop looping
            else{
              return false; //Return false so that it stops the looping and exits the loop
            }
          }//End of loop_function
        };//End of loop Node
        
        //Instructions block for phase 2 of faces trials
        var faceInstructions2 = makeFaceInstructions2();
        
        //instruction block for RDK trials
        var RDKInstructions=makeRDKInstructions(); 
        
        //instructions block for line coherence trials
        var LineCoherenceInstructions=makeLineCoherenceInstructions(); 
        
        
        
        //Debrief block
        var debriefBlock = makeDebriefBlock();
        
        //Timeline array to be fed into the jsPsych.init function
        var timeline = [];
       // timeline.push(makeFullscreenBlock());


        
        
        //==================================
        //======== FUNCTIONS BEGIN =========
        //==================================
        
        //Function to extract the info of the path name to be properties of the stimuli object
        function extractInfo(stimuliArray){
          
          //Temporary array to store all the modified objects
          var tempArray = [];
          
          //Loop through all the stimuli objects in the stimuli array
          for(var i  = 0; i < stimuliArray.length; i++){
            
            //Load in the current object
            var currentObject = stimuliArray[i];
            
            //Get the face number
            var currentFaceNumber = currentObject.path.match(/\d\d/)[0];
            
            //Get the gender
            var currentGender = currentObject.path.match(/M|F/)[0];
            
            //Load in the gender and the face number as properties of the object
            currentObject.faceNumber = Number(currentFaceNumber);
            currentObject.gender = currentGender;
            
            //Push the modified object into the temp array
            tempArray.push(currentObject);
            
          }//End of for loop
          
          //Return the tempArray
          return tempArray;
          
        }//End of extractInfo function
        
        //Function to return the block that makes the experiment fullscreen
        function makeFullscreenBlock(){
          return{
            type: 'fullscreen',
            button_label: 'Next >',
            message: wrapperStart +
              'When you click "Next" below, your browser will be in fullscreen mode.<p></p>' +
              wrapperEnd,
            fullscreen_mode: true
          };
        }
        
        //Function to make the first instructions block
        function makeWelcomeInstructions(){
          
          //---------- Welcome Screen ----------
          
          //Welcome Screen Text
          var welcomeScreenText = wrapperStart +
            "Welcome to the experiment!<br/><br/>" + 
            "There will be three phases to this experiment, and you will receive separate instructions for each phase.<p></p>" +
            wrapperEnd;
            
          //Create the welcome screen
          var welcomeScreen = {
            type: 'instructions',
            pages:[
              welcomeScreenText
            ],
            show_clickable_nav: true
          };
          return {
			timeline: [
              welcomeScreen
           	]
          };
          
        }//End of makeWelcomeInstructions function
        
        function makeFaceInstructions1(){
          //---------- Instructions ----------

          //Instructions prompt
          var htmlContent = wrapperStart +
            "<p> This phase has two tasks. Your first task in this phase is to <b>rate the attractiveness</b> of each of the faces that are presented. <br/>" + 
            "Here is an image of a sample trial:<br/></p>" +
            "<img style='height:450px; width:800px; border:2px solid black; border-radius: 5px' src='../static/images/samplePhase1TrialImage.png'>" + 
            "<p>Slide the slider based on how attractive or unattractive you think they are. <br/><br/>" +
            "Drag the slider to the <b>left</b> if they are <b>unattractive</b>, and drag the slider to the <b>right</b> if you think they are <b>attractive</b>.</p>" +
            wrapperEnd;
            
          //Create the instructions with the image
          var instructionsScreen = {
            type: 'html-button-response',
            stimulus: htmlContent,
            choices: ['Next >'],
            prompt: wrapperStart +
              'Press "Next" to continue.' +
              wrapperEnd
          };
          
          //---------- Animation ----------
            
          //Animation
          var animationScreen = {
            type: 'animation',
            stimuli: facePhase1AnimationArray,
            sequence_reps: 1,
            prompt: wrapperStart +
              '<br/> This is a demonstration of four trials. <br/>' + wrapperEnd
          };
          
          //---------- End Of Instructions ----------
            
          //End of instructions instructions
          var endOfInstructionsText = wrapperStart +
          
            "Also, you cannot advance unless you move the slider. <br/><br/>" +
            "There are no right or wrong answers in this experiment, so just respond based on what feels right for you. <br/><br/>"+
            "Click 'Next' to start the experiment." +
            wrapperEnd;
            
          var endOfInstructionsScreen = {
            type: 'instructions',
            pages:[
              endOfInstructionsText
            ],
            show_clickable_nav: true
            
          };
          
          //---------- Put it all together ----------
          
          return {
            timeline: [
              instructionsScreen,
             // animationScreen,
              endOfInstructionsScreen
            ]
          };
          
        }//End of makeFaceInstructions1 function
        
        //Function to make the second instructions block
        function makeFaceInstructions2(){
            
          //---------- Welcome Screen ----------
          
          //Phase2 Intro Text
          var phase2IntroText = wrapperStart +
            "Great job!<br/><br/>" + 
            "We will now move on to the second task of this phase of the experiment." +
            wrapperEnd;
            
          //Create the welcome screen
          var phase2IntroScreen = {
            type: 'instructions',
            pages:[
              phase2IntroText
            ],
            show_clickable_nav: true
          };
            
          //---------- Instructions ----------

          //Instructions prompt
          var htmlContent = wrapperStart +
            "<p>Your second task in this phase is to <b>click on the most attractive face.</b><br/><br/>" + 
            "Here is an image of a sample trial:<br/></p>" +
            "<img style='height:450px; width:800px; border:2px solid black; border-radius: 5px' src='../static/images/samplePhase2TrialImage.png'>" + 
            "<p> Once you have chosen the most attractive face, a slider will be presented.<br/><br/>" + 
            "<b>Slide the slider based on how confident you are about your choice.</b><br/>" +
            wrapperEnd;
            
          //Create the instructions with the image
          var instructionsScreen = {
            type: 'html-button-response',
            stimulus: htmlContent,
            choices: ['Next >'],
            prompt: wrapperStart +
              'Press "Next" to continue.' +
              wrapperEnd
          };
          
          //---------- Animation ----------
            
          //Animation
          var animationScreen = {
            type: 'animation',
            stimuli: facePhase2AnimationArray,
            frame_time: 500,
            sequence_reps:1,
            prompt: wrapperStart +
            '<br/> This is a demonstration of two trials. <br/> '+
            wrapperEnd

          };
          
            
          //---------- End Of Instructions ----------
            
          //End of instructions instructions
          var endOfInstructionsText = wrapperStart +
            "Just as before, you cannot advance unless you move the slider. <br/><br/>" +
           "And once again, there are no right or wrong answers, so just answer based on what feels right to you. <br/><br/>" +
            "Click 'Next' to start this part of the experiment." +
            wrapperEnd;
            
          var endOfInstructionsScreen = {
            type: 'instructions',
            pages:[
              endOfInstructionsText
            ],
            show_clickable_nav: true
            
          };
          
          //---------- Put it all together ----------
          
          return {
            timeline: [
              phase2IntroScreen,
              instructionsScreen,
              //animationScreen,
              endOfInstructionsScreen
            ]
          };
          
        }//End of makeFaceInstructions2 function
        
        
        
        
        //Function to make the RDK instructions block
        function makeRDKInstructions(){
            
            
          //---------- Instructions ----------

          //Instructions prompt
          var htmlContent = wrapperStart +
            "<p>Each trial will contain three apertures with moving dots. <b> Your task this phase is to figure out which aperture has the greatest proportion of dots moving towards the right. <b> Click on the aperture with the most dots moving towards the right.</b><br/><br/>" + 
            "Here is an image of a sample trial:<br/></p>" +
            "<img style='height:450px; width:800px; border:2px solid black; border-radius: 5px' src='../static/images/samplePhase2TrialImage.png'>" + 
            "<p> Once you have chosen the aperture with the most dots moving towards the right, a slider will be presented.<br/><br/>" + 
            "<b>Slide the slider based on how confident you are about your choice.</b><br/>" +
            wrapperEnd;
            
          //Create the instructions with the image
          var instructionsScreen = {
            type: 'html-button-response',
            stimulus: htmlContent,
            choices: ['Next >'],
            prompt: wrapperStart +
              'Press "Next" to continue.' +
              wrapperEnd
          };
          
          //---------- Animation ----------
            
          //Animation
          var animationScreen = {
            type: 'animation',
            stimuli: facePhase2AnimationArray,
            frame_time: 500,
            sequence_reps:1,
            prompt: wrapperStart +
            '<br/> This is a demonstration of a couple of trials.' +
            wrapperEnd

          };
          
            
          //---------- End Of Instructions ----------
            
          //End of instructions instructions
          var endOfInstructionsText = wrapperStart +
            "Just as before, you cannot advance unless you move the slider. <br/><br/>" +
            "Click 'Next' to start this part of the experiment." +
            wrapperEnd;
            
          var endOfInstructionsScreen = {
            type: 'instructions',
            pages:[
              endOfInstructionsText
            ],
            show_clickable_nav: true
            
          };
          
          //---------- Put it all together ----------
          
          return {
            timeline: [
              instructionsScreen,
             // animationScreen,
              endOfInstructionsScreen
            ]
          };
          
        }//End of makeRDKInstructionsfunction
        
        
                //Function to make the line coherence instructions block
        function makeLineCoherenceInstructions(){
            
            
          //---------- Instructions ----------

          //Instructions prompt
          var htmlContent = wrapperStart +
            "<p>Each trial will contain three stimuli with a cluster of lines. <b> Your task this phase is to figure out which stimulus has the greatest proportion of lines tilted in the exact same direction. <b> Click on the stimulus with the most lines tilted in the same direction.</b><br/><br/>" + 
            "Here is an image of a sample trial:<br/></p>" +
            "<img style='height:450px; width:800px; border:2px solid black; border-radius: 5px' src='../static/images/samplePhase2TrialImage.png'>" + 
            "<p> Once you have chosen the aperture with the most dots moving towards the right, a slider will be presented.<br/><br/>" + 
            "<b>Slide the slider based on how confident you are about your choice.</b><br/>" +
            wrapperEnd;
            
          //Create the instructions with the image
          var instructionsScreen = {
            type: 'html-button-response',
            stimulus: htmlContent,
            choices: ['Next >'],
            prompt: wrapperStart +
              'Press "Next" to continue.' +
              wrapperEnd
          };
          
          //---------- Animation ----------
            
          //Animation
          var animationScreen = {
            type: 'animation',
            stimuli: facePhase2AnimationArray,
            frame_time: 500,
            sequence_reps:1,
            prompt: wrapperStart +
            '<br/> This is a demonstration of a couple of trials.' +
            wrapperEnd

          };
          
            
          //---------- End Of Instructions ----------
            
          //End of instructions instructions
          var endOfInstructionsText = wrapperStart +
            "Just as before, you cannot advance unless you move the slider. <br/><br/>" +
            "Click 'Next' to start this part of the experiment." +
            wrapperEnd;
            
          var endOfInstructionsScreen = {
            type: 'instructions',
            pages:[
              endOfInstructionsText
            ],
            show_clickable_nav: true
            
          };
          
          //---------- Put it all together ----------
          
          return {
            timeline: [
              instructionsScreen,
             // animationScreen,
              endOfInstructionsScreen
            ]
          };
          
        }//End of makeLineCoherenceInstructionsfunction
        
        
        
        
        
        
        
        
        
        //Function to make the third instructions block
        function makeInstructions3(){
          
          //Page 1 instructions
          var page1 = wrapperStart +
            "Amazing work on phase 2! <br/><br/>" + 
            "You are almost done! <br/><br/>" + 
            "We will now move on to phase 3 of the experiment." +
            wrapperEnd;
            
          //Page 2 instructions
          var page2 = wrapperStart +
            "Phase 3 is a set of 21 simple yes/no questions.<br/><br/>" +
            "You will have to answer all the questions to continue.<br/><br/>" +
            "We ask that you answer this truthfully as your responses are anonymous and will not affect your compensation." +
            wrapperEnd;
            
          //Load it into a trial object and return it
          return {
            type: 'instructions',
            pages:[
              page1,
              page2
            ],
            show_clickable_nav: true
          };
          
        }//End of makeInstructions3 function
        
        
        //Function to make phase 1 (the face rating phase)
        function make_faces_Phase1(){
          
          //Make an array to store all the trials for the first part of phase 1
          var faces_phase1Part1 = [];
          
          //Make a template trial object to rate the faces
          var simObject = {
            type: 'image-slider-response',
            stimulus: '<p> Filler stimulus </p>',//Stimulus will be replaced by the image below
            labels: ['Extremely unattractive', 'Extremely attractive'],
            prompt: "How attractive is this person?<br/>",
            button_label: 'Submit',
            response_ends_trial: true,
            on_finish: function(data){
              
              //Determine the gender of the face
              var gender = data.gender;
              
              //Select the array based on the gender
              if(gender === "M"){
                var relevantArray = male_stimuli; //Assignment operator: Points to the same array, not a copy
              }
              else if(gender === "F"){
                var relevantArray = female_stimuli; //Assignment operator: Points to the same array, not a copy
              }
              
              //Look for the object in the relevant array
              for(var i in relevantArray){
                
                //Load in the current object for easy handling
                var currentObject = relevantArray[i];
                
                //If the stimuli matches the path of the object, then we have the correct array
                if(data.path === currentObject.path){
                  
                  //If the rating1 key is not defined, then add the response rating as the rating (as this is probably the first round of ratings)
                  if( !("rating1" in currentObject) ){
                    currentObject.rating1 = data.response;
                  }
                  //Else if the rating2 key is not defined, then we add the response as rating 2 and calculate the average
                  else if ( !("rating2" in currentObject) ){
                    currentObject.rating2 = data.response;
                    //Calculate the average rating
                    var averageRating = (currentObject.rating1 + currentObject.rating2)/2;
                    //Add it into the currentObject
                    currentObject.averageRating = averageRating;
                  }//End of inner if
                }//End of outer if
              }//End of for loop
              
              //If the subject took longer than 1 second to answer, then set the flag to false
              if(data.rt > 1000){
                subjectAnsweredAllPhase1Below1Second = false;
              }
              
            }//End of on_finish
          };//End of simObject
          
          //Load in all the paths for male and female faces
          for(var i in female_stimuli){
            
            //---Female---
            
            //Create a new object for the trial
            var newSimObject1 = Object.assign({},simObject);
            //Add in the stimulus path
            newSimObject1.stimulus = female_stimuli[i].path;
            //Add in the data for the trial
            newSimObject1.data = {
              gender: female_stimuli[i].gender,
              faceNumber: female_stimuli[i].faceNumber,
              path: female_stimuli[i].path
            }
            //Push it into the main array
            faces_phase1Part1.push(newSimObject1);
            
            //---Male---
            
            //Create a new object for the trial
            var newSimObject2 = Object.assign({},simObject);
            //Add in the stimulus path
            newSimObject2.stimulus = male_stimuli[i].path;
            //Add in the data for the trial
            newSimObject2.data = {
              gender: male_stimuli[i].gender,
              faceNumber: male_stimuli[i].faceNumber,
              path: male_stimuli[i].path
            }
            //Push it into the main array
            faces_phase1Part1.push(newSimObject2);
            
          }//End of for loop
          
          //Shuffle the array and save it as the first part
          var faces_phase1Part1 = jsPsych.randomization.shuffle(faces_phase1Part1);
          
          //Make a copy of the previous array, shuffle it, and save it as the second part
          var faces_phase1Part2 = jsPsych.randomization.shuffle(faces_phase1Part1.slice(0));
          
          //Concatenate the arrays to form the first phase
          var faces_phase1Array = faces_phase1Part1.concat(faces_phase1Part2);
          
          //Shuffle the array and return it
          return {
            type: 'image-slider-response',
            timeline: faces_phase1Array
          };//End of return
        }//End of makePhase1
        
        
        
        
        function faces_makePrepForPhase2() {
         return {
            type: 'call-function',
            func: function(){
            
             //Loop twice: once for male, and once for female
              for(var j = 0; j < 2; j++){
                
                //If first iteration, then use the male stimuli array
                if(j === 0){
                  var relevantArray = male_stimuli;
                }
                //If second iteration, then use the female stimuli array
                else if(j === 1){
                  var relevantArray = female_stimuli;
                }
                
                truncateArray(relevantArray);
                
                 //Print out the array to see it
           //      console.log("relevantArray sorted by differenceRating:");
//                 console.log(JSON.parse(JSON.stringify(relevantArray)));
                
    
                //Calculate rankings and sort the array based on averageRating
                calculateRankings(relevantArray);
                
                } //end of for loop 
                male_combos= makeTargetsAndNontargetsAndCombos(male_stimuli); 
                female_combos=makeTargetsAndNontargetsAndCombos(female_stimuli);
                maleAFC3trials=make_3AFC_face_trials(male_combos); 
                femaleAFC3trials=make_3AFC_face_trials(female_combos);
                //make3AFCTrials();// i need to change the 3AFC trials to fit what i want              
                //phase2Array = jsPsych.randomization.shuffle(AFC3Array);
        		faces_phase2Array = jsPsych.randomization.shuffle(maleAFC3trials.concat(femaleAFC3trials));
      		  	//timeline.push(faces_phase2Array);

        }//end of func
        }//end of return
        }//end of make prep for phase 2
        
        
        function make_3AFC_face_trials(combos)
		{
			var trials=[];
			for(var i=0; i<combos.length; i++)
			{
				trials=trials.concat(make_face_TrialFromTriplet(combos[i]));  
			}
			return trials; 
		}
        
        
        
        //function to make the targets and the nontargets
        function makeTargetsAndNontargetsAndCombos(relevantArray){
        	targets=[]; //global variable
        	nontargets=[]; //global variable
        
         for(var i = 0; i < relevantArray.length; i++){
        	if(relevantArray[i].rank<=nfacesTargets) ///the top five will be targets
        		targets.push(relevantArray[i]); 
        	else 
        		nontargets.push(relevantArray[i]);
			//here maybe i can call the make all combos thing :) :) 
 
 
        	}//end of for loop
        var combos=make_all_face_combos(targets,nontargets); 
        return combos; 
        
        }//end of maketargetsandnontargetsfxn
        
        //this function takes the targets and nontargets and makes all possible combos of 2 targets and one nontarget 
		function make_all_face_combos(targets, nontargets) //make all combos doesn't work with phase 2 script, so fix that. 
		{

			
			var result=[]; 
			var pairs=[]; 
			for (var i=0; i<targets.length-1; i++)
			{	
			for(var j=i+1;j<targets.length; j++)
			{
				var mini=[]; 
				mini.push(targets[i]); 
				mini.push(targets[j]); 
				pairs.push(mini); 
			}
			}

			
			for(var i=0; i<pairs.length; i++)
			{
				var a=pairs[i][0];
				var b=pairs[i][1];
			
				for(var j=0; j<nontargets.length; j++)
				{
					var c=nontargets[j]; 
					var mini2=[];  
					mini2.push(a); 
					mini2.push(b); 
					mini2.push(c);
					mini2 = jsPsych.randomization.repeat(mini2, 1); 
					result.push(mini2); 
					//return result; // remove line!!!
				}
			}
			return result;  
		} 
        

        //Function to take out the faces with the largest rating differences
        function truncateArray(relevantArray){
          
          //For loop to calculate the difference between the first and second faces
          for(var i = 0; i < relevantArray.length; i++){
            
            //Get the difference and ad it in as an attribute to the object
            relevantArray[i].ratingDifference = Math.abs(relevantArray[i].rating1 - relevantArray[i].rating2);
            
          }//End of for loop
          
          //Sort the array based on their ratingDifference (smallest to largest)
          relevantArray = relevantArray.sort(function(a,b){return (a.ratingDifference - b.ratingDifference); });
          
          //Truncate the array to the desired length
          relevantArray.length = nFacesPerGender;
          
        }//End of truncateArray
        
        //Function to rank the faces within each gender
        function calculateRankings(relevantArray){
          
          //Sort the array of faces based on the z-score (start of array is highest score)
          relevantArray = relevantArray.sort(function(a,b){return (b.averageRating - a.averageRating); });
          
          //Assign the rankings to the array
          for(var i = 0; i < relevantArray.length; i++){
            relevantArray[i].rank = i+1;
          }
          
        }//End of calculateRankings
        

        
        
        //Function to make the image html tag
        function makeImageHTML(path){
          
          //Get the width of the window
          var windowWidth = window.innerWidth;
          
          //Calculate the width of the image
          var imageWidth = windowWidth/4; //Scale it down so that all 3 can fit comfortably
          
          //Constrain the width if it is too large (for very wide screens)
          if(imageWidth > 450){
            imageWidth = 450;
          }
          
          //Return the image tag with the formatting
          return '<img src=' + path + ` style="width:${imageWidth}px; height:auto;">`;
        
        }//End of makeImageHTML
        
        //Function to make the targets and the nontargets
           
        
        //Function to make a trial from the triplet
        function make_face_TrialFromTriplet(triplet){
          
          //Sort the triplet of faces based on the z-score (start of array is highest score)
          triplet = triplet.sort(function(a,b){return (b.rank - a.rank); });
          
          //Tag the faces
          triplet[0].faceType = "target";
          triplet[1].faceType = "non-target";
          triplet[2].faceType = "distractor";

        
          //Shuffle the triplet to randomize the faces
          var shuffledTriplet = jsPsych.randomization.shuffle(triplet);
          
          //Load in the faces for easy handling
          var stim1 = shuffledTriplet[0];
 
          var stim2 = shuffledTriplet[1];
          var stim3 = shuffledTriplet[2];

          //Make the choice trial object
          var choiceTrial = {
            type: 'html-button-response',
            stimulus: '',
            prompt: '<p> Which face is most attractive? </p>',
            choices: [
              makeImageHTML(stim1.path),
              makeImageHTML(stim2.path),
              makeImageHTML(stim3.path)
            ],
            //The data that is included in the trial
            data: {
              //Log in the general trial data
              taskType: "Faces Choice Trial",
              gender: stim1.gender,
              //Face 1 data
              faceNumber1:stim1.faceNumber,
              stimType1: stim1.faceType,
              stimRank1: stim1.rank,
              //Face 2 data
              faceNumber2:stim2.faceNumber,
              stimType2: stim2.faceType,
              stimRank2: stim2.rank, 
              //Face 3 data
              faceNumber3:stim3.faceNumber,
              stimType3: stim3.faceType, 
              stimRank3: stim3.rank
            },
            on_finish: function(data){
            	addfacesDataToTrial(data); 
            	}
     
          };//End of choiceTrial
          
          //Make the confidence trial object
          var confidenceTrial = {
            type: 'html-slider-response',
            stimulus: '',
            labels: ['Extremely unconfident','Extremely confident'],
            start: 0,
            prompt: 'How confident are you in your choice?',
            data: {
              taskType: "Faces Confidence",
            },
            on_start: function(trial){
           		confidence_on_start(trial); 
            },
            on_finish: function(data){
            	confidence_on_finish(data); 
            }
          };//End of confidenceTrial
          
          
          //Make a trial object and return it
          return {
            type:'html-button-response', //This will be overridden by those of the trial
           
            timeline: [choiceTrial,confidenceTrial]
            //timeline: [choiceTrial]
          };
          
        }//End of makeTrialFromTriplet
        

        
        //Function to add the data to the final iteration
        function addfacesDataToTrial(data){
          //Get the face that was chosen, in the form of 0 or 1 (0 means first face, 1 means second face).
          var choice = parseInt(data.button_pressed); //Parse it from string to int
          
          //If subject chose the target face
          if( 
            (choice === 0 && data.stimType1 === "target") || 
            (choice === 1 && data.stimType2 === "target") || 
            (choice === 2 && data.stimType3 === "target") 
            ){
            //Add to the data to the data object to be saved
            data.correct = true;
            data.chosenStim = "target";
          }
          //Else if they chose the non-target
          else if( 
            (choice === 0 && data.stimType1 === "non-target") || 
            (choice === 1 && data.stimType2 === "non-target") || 
            (choice === 2 && data.stimType3 === "non-target") 
            ){
            //Add to the data to the data object to be saved
            data.correct = false;
            data.chosenStim= "non-target";
          }
          //Else if they chose the distractor
          else if( 
            (choice === 0 && data.stimType1 === "distractor") || 
            (choice === 1 && data.stimType2 === "distractor") || 
            (choice === 2 && data.stimType3 === "distractor") 
            ){
            //Add to the data to the data object to be saved
            data.correct = false;
            data.chosenStim = "distractor";
          }
          
          //If the subject chose the first face
          if(choice === 0){
            //Add the z-score data of the chosen face
            data.chosenFaceNumber=data.faceNumber1; 
            data.chosenRank=data.stimRank1; 
          }
          //Else if the subject chose the second face
          else if(choice === 1){
            //Add the z-score data of the chosen face
            data.chosenFaceNumber=data.faceNumber2; 
            data.chosenRank=data.stimRank2; 

          }
          //Else if the subject chose the third face
          if(choice === 2){
            //Add the z-score data of the chosen face
            data.chosenFaceNumber=data.faceNumber3;  
            data.chosenRank=data.stimRank3; 
          }
          
          if(data.stimType1==='target')
          {
          	data.correctFaceNumber=data.faceNumber1; 
          	data.correctRank=data.stimRank1; 
          	
          }
          else if(data.stimType2==='target')
          {
          	data.correctFaceNumber=data.faceNumber2; 
          	data.correctRank=data.stimRank2; 
          }
            else if(data.stimType3==='target')
          {
          	data.correctFaceNumber=data.faceNumber3; 
          	data.correctRank=data.stimRank3; 
          }
          
          
          
        }//End of addDataToTrial
        
        //Function to add the data to the confidence trial using the on_start function
        function confidence_on_start_function(trial){
          //Get the data object from the last trial
          var data = jsPsych.data.get().last(1).values()[0];
          //Get the chosen number from the choice trial data object
          var chosenStim = data.chosenStim;
          //Add that information to the confidence trial's data
          trial.data.chosenStim = chosenStim;
          
        }
        
        //Function to add the data to the choice trial using the on_finish function
        function confidence_on_finish_function(data){
          //Get the data object from the last two trials
          var lastTwoDataObjects = jsPsych.data.get().last(2).values();
          //Get the data of the second last data object (the one from the choice trial)
          var choiceTrial = lastTwoDataObjects[0]; //[0] is the choice trial
          //Add in the response of this the confidence trial to choice trial
          choiceTrial.response = data.response;
        }
        
        
        //Function to make the debrief block
        function makeDebriefBlock(){
          
          //Page 1 instructions
          var page1 =  wrapperStart +
            "Great work!<br/><br/>" + 
            "You have successfully completed the experiment.<br/><br/>" +
            "Click on the 'Next' button to officially end the experiment and submit the HIT." +
            wrapperEnd;
            
          //Load it into a trial object and return it
          return {
            type: 'instructions',
            pages:[
              page1
            ],
            on_start: function(){
              //Set the variable to true so that we submit the HIT
              all_face_PhasesCompleted = true;
            },
            show_clickable_nav: true
          };//End of return
          
        }//End of makeDebriefBlock function
        

        //================================
        //======== FUNCTIONS END =========
        //================================        

                /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//----------------FACES CODE ABOVE THIS LINE-----------------//
        
                  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//----------------Line Coherence ABOVE THIS LINE-----------------//      
     var LineCoherencetimeline=[]; 
    
    

		
			function drawRotatedRect(x,y,width,height,degrees){
			    //function from:http://stackoverflow.com/questions/17125632/html5-canvas-rotate-object-without-moving-coordinates
			    // first save the untranslated/unrotated context
			    context.save();

			    context.beginPath();
			    // move the rotation point to the center of the rect
			    context.translate( x+width/2, y+height/2 );
			    // rotate the rect
			    context.rotate(degrees*Math.PI/180);

			    // draw the rect on the transformed context
			    // Note: after transforming [0,0] is visually [x,y]
			    //       so the rect needs to be offset accordingly when drawn
			    context.rect( -width/2, -height/2, width,height);

			    context.fillStyle="black";
			    context.fill();

			    // restore the context to its untranslated/unrotated state
			    context.restore();
			}

			function shuffle(array) {
				var currentIndex = array.length, temporaryValue, randomIndex ;

					 // While there remain elements to shuffle...
					 while (0 !== currentIndex) {

					 	// Pick a remaining element...
					 	randomIndex = Math.floor(Math.random() * currentIndex);
					 	currentIndex -= 1;

					 	// And swap it with the current element.
					 	temporaryValue = array[currentIndex];
					 	array[currentIndex] = array[randomIndex];
					 	array[randomIndex] = temporaryValue;
					 }

				return array;
			}	
		
			function createBlank() {
				context.clearRect(0, 0, canvas.width, canvas.height);
				var string4blank = myCanvas.toDataURL();
				Blank2use = string4blank;
				return Blank2use;
			}

			function createstimulus(startxpixel,startypixel,num2make,numcongruent,patternpresent) {
			      //Initialize all of the variables that you need in this function.
			      var rotations=[];
				  var rotations1=[];
				  var rotations2=[];
			      var congruentLines=[];
				  var ImageStrings = [];
			      var stim2record = [];
			      var correctAnswer = [];
				  var differencesfromcond = [];
			      var pixinc = 37.5;
  
			      //On 50% of the trials, a pattern should be present
			      //On the other 50% of trials, no pattern should be present.  
			      //You'll need to dictate this from outside this function.
      
			      //If you want to make more than one stimulus, this creates unique stimuli within the loop based on num2make.
			      //Otherwise, it just makes one.
			      for (var l = 0; l < num2make; l++) {       
 				  
			          //Label what the correct answer will be, because this value is returned later on.
			          //Also, determine the number of coherent lines based on whether a pattern is present.
					  //Remember in javascript key codes, Q = 81, and P = 80.
			          if (patternpresent===1) {
							correctAnswer[l] = 81;
							stim2record[l]=numcongruent;
					  } else {
							correctAnswer[l] = 80;
							numcongruent=0;
							stim2record[l]=0;
			          }
        
			        //Create the congruent rotations for the pre-specified number that will be staircased.
			          var congruentrotation = (Math.random()*360);
					  for (var i = 0; i < numcongruent; i++) {
						  rotations1[i] = congruentrotation;
			          }
				
			          //Create the random rotations for the rest of the lines.
			          var randomrotations = (25-(rotations1.length));
					  for (var k = 0; k < randomrotations; k++) {
					      rotations2[k] = (Math.random()*360);
			              var checkiftooclose = Math.abs((rotations2[k]-congruentrotation));
			              if (checkiftooclose<10) {
			                  rotations2[k] = rotations2[k]+10;
			              }
					   }
			
			  	      rotations = rotations1.concat(rotations2);
						    shuffle(rotations);
  
			          for (var j = -3; j < 4; j++) {
					            if ( j === -3 ) {
			                      var stpx = startxpixel + 0; 
			                      var numelements = 1;
			                      for (var k = 0; k < numelements; k++) {
			                            jitterx = (Math.random()*6)-3;
								        jittery = (Math.random()*6)-3;
			                            drawRotatedRect(centerWidth - stpx + (k*pixinc),centerHeight -  j*pixinc,rectWidth,rectHeight,rotations[k]);
			                      }
			                } else if (j === -2) {
			                      var stpx = startxpixel + 37.5;
								  var numelements = 3;
			                      for (var k = 0; k < numelements; k++) {
			                            jitterx = (Math.random()*6)-3;
								        jittery = (Math.random()*6)-3;
			                            drawRotatedRect(centerWidth - stpx + (k*pixinc),centerHeight -  j*pixinc,rectWidth,rectHeight,rotations[k+1]);
			                      }
			                } else if (j === -1) {
			                      var stpx = startxpixel + 75;
			                      var numelements = 5;
			                      for (var k = 0; k < numelements; k++) {
									    jitterx = (Math.random()*6)-3;
									    jittery = (Math.random()*6)-3;
			                            drawRotatedRect(centerWidth - stpx + (k*pixinc),centerHeight -  j*pixinc,rectWidth,rectHeight,rotations[k+4]);
			                      }  
			                } else if (j === 0) {
			                      var stpx = startxpixel + 112.5;
			                      var numelements = 7;
			                      for (var k = 0; k < numelements; k++) {
			                    		jitterx = (Math.random()*6)-3;
									    jittery = (Math.random()*6)-3;
			                            drawRotatedRect(centerWidth - stpx + (k*pixinc),centerHeight -  j*pixinc,rectWidth,rectHeight,rotations[k+9]);
			                      }
			                } else if (j === 1) {
			                      var stpx = startxpixel + 75;
			                      var numelements = 5;
			                      for (var k = 0; k < numelements; k++) {
			                            jitterx = (Math.random()*6)-3;
									    jittery = (Math.random()*6)-3;
			                            drawRotatedRect(centerWidth - stpx + (k*pixinc),centerHeight -  j*pixinc,rectWidth,rectHeight,rotations[k+16]);
			                      }
			                } else if (j === 2) {
			                      var stpx = startxpixel + 37.5;
			                      var numelements = 3;
			                      for (var k = 0; k < numelements; k++) {
			                            jitterx = (Math.random()*6)-3;
									    jittery = (Math.random()*6)-3;
			                            drawRotatedRect(centerWidth - stpx + (k*pixinc),centerHeight -  j*pixinc,rectWidth,rectHeight,rotations[k+21]);
			                      }
			                } else if (j === 3) {
			                      var stpx = startxpixel + 0;
			                      var numelements = 1;
			                      for (var k = 0; k < numelements; k++) {
			                            jitterx = (Math.random()*6)-3;
									    jittery = (Math.random()*6)-3;
			                            drawRotatedRect(centerWidth - stpx + (k*pixinc),centerHeight -  j*pixinc,rectWidth,rectHeight,rotations[k+24]);
			                      }
			                }
			            }
			            var string4image = myCanvas.toDataURL();
					    ImageStrings = string4image;
						context.clearRect(0, 0, canvas.width, canvas.height);	
				 
			      }
			      return {
						//ImageStrings
			      	  type: "call-function",
					 func: my_func,
			         ImageStrings: ImageStrings,
			         numCongruent: numcongruent,
			          //correctAnswer: correctAnswer,
					  //stim2record: stim2record, 
					//  stimulus: ImageStrings, 
					 stimuli: ImageStrings
					  //stimulus:''
					  //choices:[]
			      }
			}
			
			
			function my_func()
			{
				console.log('hello');  
			
			}
			
			 //Function to make the image html tag
        function LineCoherencemakeImageHTML(url){
          
          //Get the width of the window
          var windowWidth = window.innerWidth;
          
          //Calculate the width of the image
          var imageWidth = windowWidth/4; //Scale it down so that all 3 can fit comfortably
          
          //Constrain the width if it is too large (for very wide screens)
          if(imageWidth > 450){
            imageWidth = 450;
          }
           var c = document.getElementById("myCanvas");
           var ctx = c.getContext("2d");
           var img = new Image();
           img.onload = function() {
            ctx.drawImage(img, 0, 0);
			};
			// img.src = url;
// 			img.style= width:${imageWidth}px; height:auto;
// 			return img; 
          
          //Return the image tag with the formatting
          return '<img src=' + url + ` style="width:${imageWidth}px; height:auto;">`;
        
        }//End of makeImageHTML
			
			
			
			
			//Change the example "Left Tilt/Right tilt" stim to patterns
			//var leftTiltStim = createstimulus(-45,90,0,0,1,1);
			//var rightTiltStim = createstimulus(45,90,0,0,1,1);
			
			var zeroCoherentLineStim = createstimulus(0,0,1,0,1);
			var twoCoherentLineStim = createstimulus(0,0,1,2,1);
			var fourCoherentLineStim = createstimulus(0,0,1,4,1);
			var sixCoherentLineStim = createstimulus(0,0,1,6,1);
			var eightCoherentLineStim = createstimulus(0,0,1,8,1);
			var tenCoherentLineStim = createstimulus(0,0,1,10,1);
			var twelveCoherentLineStim = createstimulus(0,0,1,12,1);
			var fourteenCoherentLineStim = createstimulus(0,0,1,14,1);
			var sixteenCoherentLineStim = createstimulus(0,0,1,16,1);
			var eighteenCoherentLineStim = createstimulus(0,0,1,18,1);
			var twentyCoherentLineStim = createstimulus(0,0,1,20,1);
			var twentytwoCoherentLineStim = createstimulus(0,0,1,22,1);			 
	
			
	LineCoherenceShortTargetStim=[fourCoherentLineStim, sixCoherentLineStim]; 
    LineCoherenceShortNontargetStim=[zeroCoherentLineStim, twoCoherentLineStim]; 
	
			
	LineCoherenceTargetStimuli=[fourteenCoherentLineStim, sixteenCoherentLineStim, eighteenCoherentLineStim,twentyCoherentLineStim, twentytwoCoherentLineStim];
	LineCoherenceNontargetStimuli=[zeroCoherentLineStim, twoCoherentLineStim, fourCoherentLineStim, sixCoherentLineStim,eightCoherentLineStim, tenCoherentLineStim, twelveCoherentLineStim];
	
	calculateLineCoherenceRankings(LineCoherenceShortTargetStim,LineCoherenceShortNontargetStim); 
	//Function to rank the faces within each gender
        function calculateLineCoherenceRankings(target_stimuli, nontarget_stimuli){
    
    	for(var i=0; i<nontarget_stimuli.length; i++)
		{
			nontarget_stimuli[i].rank=i+1; 	
		}
	
	
		for(var i=0; i<target_stimuli.length; i++)
		{
			target_stimuli[i].rank=target_stimuli.length+i+1; 
		}
  	        
          
        }//End of calculateRankings
	


    LineCoherenceCombos=make_all_LineCoherence_combos(LineCoherenceShortTargetStim, LineCoherenceShortNontargetStim); 


//****MAKE SURE TO CHANGE COMBOS TO THE LONGER ONE LATER: SHORTER JUST TO RUN THROUGH FAST. 
	//combos=make_all_combos(target_stimuli, nontarget_stimuli); 

	allLineCoherenceTrials=make_LineCoherence_trials(LineCoherenceCombos);
	LineCoherencetimeline=LineCoherencetimeline.concat(allLineCoherenceTrials);

	//Function to add the data to the final iteration
        function addLineCoherenceDataToTrial(data){
          
          //Get the face that was chosen, in the form of 0 or 1 (0 means first face, 1 means second face).
          var choice = parseInt(data.button_pressed); //Parse it from string to int
          
          //If subject chose the target face
          if( 
            (choice === 0 && data.stimType1 === "target") || 
            (choice === 1 && data.stimType2 === "target") || 
            (choice === 2 && data.stimType3 === "target") 
            ){
            //Add to the data to the data object to be saved
            data.correct = true;
            data.chosenStim = "target";
          }
          //Else if they chose the non-target
          else if( 
            (choice === 0 && data.stimType1 === "non-target") || 
            (choice === 1 && data.stimType2 === "non-target") || 
            (choice === 2 && data.stimType3 === "non-target") 
            ){
            //Add to the data to the data object to be saved
            data.correct = false;
            data.chosenStim = "non-target";
          }
          //Else if they chose the distractor
          else if( 
            (choice === 0 && data.stimType1 === "distractor") || 
            (choice === 1 && data.stimType2 === "distractor") || 
            (choice === 2 && data.stimType3 === "distractor") 
            ){
            //Add to the data to the data object to be saved
            data.correct = false;
            data.chosenStim = "distractor";
          }
          
          //If the subject chose the first face
          if(choice === 0){
            //Add the z-score data of the chosen face
            data.chosenNumCongruent=data.stim1NumCongruent;
            data.chosenRank = data.stimRank1;
            
            
          }
          //Else if the subject chose the second face
          else if(choice === 1){
            //Add the z-score data of the chosen face
            data.chosenNumCongruent=data.stim2NumCongruent; 
            data.chosenRank = data.stimRank2;
          }
          //Else if the subject chose the third face
          else if(choice === 2){
            //Add the z-score data of the chosen face
            data.chosenNumCongruent=data.stim3NumCongruent; 
            data.chosenRank = data.stimRank3;
          }
          
          if(data.stimType1==='target')
          {
          	data.correctNumCongruent=data.stim1NumCongruent; 
          	data.correctRank=data.stimRank1; 
          	
          }
          else if(data.stimType2==='target')
          {
          	data.correctNumCongruent=data.stim2NumCongruent; 
          	data.correctRank=data.stimRank2; 
          }
            else if(data.stimType3==='target')
          {
          	data.correctNumCongruent=data.stim3NumCongruent; 
          	data.correctRank=data.stimRank3; 
          }
          
          
        }//End of addDataToTrial
		
	   //Function to add the data to the confidence trial using the on_start function
        function confidence_on_start_function(trial){
          //Get the data object from the last trial
          var data = jsPsych.data.get().last(1).values()[0];
          //Get the chosen number from the choice trial data object
          var chosenStim = data.chosenStim;
          //Add that information to the confidence trial's data
          trial.data.chosenStim = chosenStim;
          
        }
        
        //Function to add the data to the choice trial using the on_finish function
        function confidence_on_finish_function(data){
          //Get the data object from the last two trials
          var lastTwoDataObjects = jsPsych.data.get().last(2).values();
          //Get the data of the second last data object (the one from the choice trial)
          var choiceTrial = lastTwoDataObjects[0]; //[0] is the choice trial
          //Add in the response of this the confidence trial to choice trial
          choiceTrial.confidenceresponse = data.response;
          choiceTrial.response=data.response; 
        }
        	
	function make_LineCoherence_trials(combos)
		{
			var trials=[];
			for(var i=0; i<combos.length; i++)
			{
				trials=trials.concat(LineCoherencemakeTrialFromTriplet(combos[i]));  
			}
			return trials; 
		}


		        //Function to make a trial from the triplet
        function LineCoherencemakeTrialFromTriplet(triplet){
        
          var trial_timeline=[]; 
          //Sort the triplet of faces based on the z-score (start of array is highest score)
          triplet = triplet.sort(function(a,b){return (b.rank - a.rank); });
          
          //Tag the faces
          triplet[0].stimType = "target";
          triplet[1].stimType = "non-target";
          triplet[2].stimType = "distractor";
          
          
          //Shuffle the triplet to randomize the faces
          var shuffledTriplet = jsPsych.randomization.shuffle(triplet);
          
          //Load in the faces for easy handling
          var stim1 = shuffledTriplet[0];
          var stim2 = shuffledTriplet[1];
          var stim3 = shuffledTriplet[2];
          
          //Make the choice trial object
          var choiceTrial = {
            type: 'html-button-response',
            stimulus:'',
            prompt: '<p> Which stimulus has the most lines tilted in the same exact direction? </p>',
            choices: [
         		 LineCoherencemakeImageHTML(stim1.stimuli),
            	 LineCoherencemakeImageHTML(stim2.stimuli),
      			 LineCoherencemakeImageHTML(stim3.stimuli)
            ],
            //The data that is included in the trial
            data: {
            taskType: "Line Coherence Choice Trial",
              //Log in the general trial data
              //Face 1 data
              stimType1: stim1.stimType,
              stimRank1: stim1.rank,
              stim1NumCongruent: stim1.numCongruent,
              //Face 2 data
              stimType2: stim2.stimType,
              stimRank2: stim2.rank,
              stim2NumCongruent: stim2.numCongruent,
              //Face 3 data
              stimType3: stim3.stimType,
              stimRank3: stim3.rank,
              stim3NumCongruent: stim3.numCongruent
              
            },
            on_finish: function(data){
            	addLineCoherenceDataToTrial(data); 
            }
          };//End of choiceTrial
          
           //Make the confidence trial object
          var confidenceTrial = {
            type: 'html-slider-response',
            stimulus: '',
            labels: ['Extremely unconfident','Extremely confident'],
            start: 0,
            prompt: 'How confident are you in your choice?',
            data: {
              taskType: "Line Coherence Confidence",
            },
            on_start: function(trial){
            	confidence_on_start_function(trial);
            },
            
            on_finish: function(data){
            	confidence_on_finish_function(data);
            }
          };//End of confidenceTrial
          
          //Make a trial object and return it
          return {
            type:'html-button-response', //This will be overridden by those of the trial
        	//choiceTrial.concat(confidenceTrial);
            timeline: [choiceTrial, confidenceTrial]
          };
          
        }//End of makeTrialFromTriplet
        

	
	function make_all_LineCoherence_combos(targets, nontargets) //make all combos doesn't work with phase 2 script, so fix that. 
		{			
			var result=[]; 
			var pairs=[]; 
			for (var i=0; i<targets.length-1; i++)
			{	
			for(var j=i+1;j<targets.length; j++)
			{
				var mini=[]; 
				mini.push(targets[i]); 
				mini.push(targets[j]); 
				pairs.push(mini); 
			}
			}
			
			for(var i=0; i<pairs.length; i++)
			{
				var a=pairs[i][0];
				var b=pairs[i][1];
			
				for(var j=0; j<nontargets.length; j++)
				{
					var c=nontargets[j]; 
					var mini2=[];  
					mini2.push(a); 
					mini2.push(b); 
					mini2.push(c);
					mini2 = jsPsych.randomization.repeat(mini2, 1); 
					result.push(mini2); 
				}
			}
			return result;  
		} 		
	
	///////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////LINE COHERENCE CODE ABOVE THIS LINE////////////////////////////////////////////////////

	
	///////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////RDK CODE BELOW THIS LINE////////////////////////////////////////////////////

	var RDK_timeline=[]; //holds all the trials for this part of the experiment 

		var RDK_target_coherence=[
		{coherence: 0.64},
		{coherence: 0.72},
		{coherence: 0.80},
		{coherence: 0.88},
		{coherence: 0.96}
		]
		
		var RDK_nontarget_coherence=[
		{coherence: 0.08},
		{coherence: 0.16},
		{coherence: 0.24},
		{coherence: 0.32},
		{coherence: 0.40},
		{coherence: 0.48},
		{coherence: 0.56}	
		]
			
	    calculateRDKRankings(RDK_target_coherence,RDK_nontarget_coherence); 
	    
	    
	    	//Function to add the data to the final iteration
        function addRDKDataToTrial(data){
          
          //Get the face that was chosen, in the form of 0 or 1 (0 means first face, 1 means second face).
          var choice = parseInt(data.button_pressed); //Parse it from string to int
          
          //If subject chose the target face
          if( 
            (choice === 0 && data.stimType1 === "target") || 
            (choice === 1 && data.stimType2 === "target") || 
            (choice === 2 && data.stimType3 === "target") 
            ){
            //Add to the data to the data object to be saved
            data.correct = true;
            data.chosenStim = "target";
          }
          //Else if they chose the non-target
          else if( 
            (choice === 0 && data.stimType1 === "non-target") || 
            (choice === 1 && data.stimType2 === "non-target") || 
            (choice === 2 && data.stimType3 === "non-target") 
            ){
            //Add to the data to the data object to be saved
            data.correct = false;
            data.chosenStim = "non-target";
          }
          //Else if they chose the distractor
          else if( 
            (choice === 0 && data.stimType1 === "distractor") || 
            (choice === 1 && data.stimType2 === "distractor") || 
            (choice === 2 && data.stimType3 === "distractor") 
            ){
            //Add to the data to the data object to be saved
            data.correct = false;
            data.chosenStim = "distractor";
          }
          
          //If the subject chose the first face
          if(choice === 0){
            //Add the z-score data of the chosen face
            data.chosenCoherence=data.stimCoherence1;
            data.chosenRank = data.stimRank1;
            
            
          }
          //Else if the subject chose the second face
          else if(choice === 1){
            //Add the z-score data of the chosen face
            data.chosenCoherence=data.stimCoherence2; 
            data.chosenRank = data.stimRank2;
          }
          //Else if the subject chose the third face
          else if(choice === 2){
            //Add the z-score data of the chosen face
            data.chosenCoherence=data.stimCoherence3; 
            data.chosenRank = data.stimRank3;
          }
          
          if(data.stimType1==='target')
          {
          	data.correctCoherence=data.stimCoherence1 
          	data.correctRank=data.stimRank1; 
          	
          }
          else if(data.stimType2==='target')
          {
          	data.correctCoherence=data.stimCoherence2; 
          	data.correctRank=data.stimRank2; 
          }
            else if(data.stimType3==='target')
          {
          	data.correctCoherence=data.stimCoherence3; 
          	data.correctRank=data.stimRank3; 
          }

          
        }//End of addDataToTrial
	
	    
	//Function to rank the faces within each gender
        function calculateRDKRankings(target_stimuli, nontarget_stimuli){
    
    	for(var i=0; i<nontarget_stimuli.length; i++)
		{
			nontarget_stimuli[i].rank=i+1; 	
		}
	
		for(var i=0; i<target_stimuli.length; i++)
		{
			target_stimuli[i].rank=target_stimuli.length+i+1; 
		}
  	        
          
        }//End of calculateRankings

		var RDKcombos=make_all_RDK_combos(RDK_target_coherence, RDK_nontarget_coherence); 


		blocks=[];     

		var allRDKtrials=make_RDK_trials(RDKcombos);

		RDK_timeline=RDK_timeline.concat(allRDKtrials); 

		function make_RDK_trials(combos)
		{
			trials=[];
			for(var i=0; i<combos.length; i++)
			{
				trials=trials.concat(make_RDK_trial_from_triplet(combos[i]));  
			}
			return trials; 
		}

		function argMax(arr) {
		return arr.map((x, i) => [x, i]).reduce((r, a) => (a[0] > r[0] ? a : r))[1];
		}

		function make_RDK_trial_from_triplet(triplet)
		{
			
			triplet = triplet.sort(function(a,b){return (b.rank - a.rank); });
			triplet[0].stimType = "target";
          	triplet[1].stimType = "non-target";
          	triplet[2].stimType = "distractor";
          	
          	 //Shuffle the triplet to randomize the faces
          var shuffledTriplet = jsPsych.randomization.shuffle(triplet);
          
          //Load in the faces for easy handling
          var stim1 = shuffledTriplet[0];
          var stim2 = shuffledTriplet[1];
          var stim3 = shuffledTriplet[2];

        	var choiceTrial= {
        	
        		type: "RDK", 
				choices:[0,1,2], //labels for the buttons
				coherence: triplet,
				apertureType:1, 
				correct_choice: argMax(triplet),
				number_of_apertures: 3, //This needs to be set if more than one aperture
				//trial_duration: 1000000000000000000000000000000000000000000000000000,
				RDK_type: 3,
				aperture_width: 200, //Applied to all apertures if only one value
				number_of_dots: 300, //Different parameter for each aperture
				aperture_center_x: [(window.innerWidth/2)-300,window.innerWidth/2,(window.innerWidth/2)+300], //Separate the apertures on the screen (window.innerWidth/2 is the middle of the screen)
				data: {//data that i want to save; come back to this later 
				//this is what i can change here: 
				taskType: "RDK Choice Trial",
				//log in the general trial data
				//stim 1 data
				stimType1: stim1.stimType,
              	stimRank1: stim1.rank,
                stimCoherence1: stim1.coherence,
				//stim 2 data
				stimType2: stim2.stimType,
             	stimRank2: stim2.rank,
             	stimCoherence2: stim2.coherence,
				//stim 3 data
				 stimType3: stim3.stimType,
             	 stimRank3: stim3.rank,
              	 stimCoherence3: stim3.coherence
				},
				on_finish: function(data){
					addRDKDataToTrial(data);
				}
        	}; //end of choice trial 
        
 		//Make the confidence trial object
          var confidenceTrial = {
            type: 'html-slider-response',
            stimulus: '',
            labels: ['Extremely unconfident','Extremely confident'],
            start: 0,
            prompt: 'How confident are you in your choice?',
            data: {
              taskType: "RDK Confidence",
            },
            on_start: function(trial){
              	confidence_on_start_function(trial); 
            },
            on_finish: function(data){
    			confidence_on_finish_function(data);
          }
          };
          //End of confidenceTrial  
            return {
            type:'html-button-response', //This will be overridden by those of the trial
           
            timeline: [choiceTrial,confidenceTrial]
            //timeline: [choiceTrial]
          }; //end of makeTrialFromTriplet
		}

            //Function to add the data to the confidence trial using the on_start function
        function confidence_on_start_function(trial){
          //Get the data object from the last trial
          var data = jsPsych.data.get().last(1).values()[0];
          //Get the chosen number from the choice trial data object
          var chosenStim = data.chosenStim;
          //Add that information to the confidence trial's data
          trial.data.chosenStim = chosenStim;
          
        }
        
         //Function to add the data to the choice trial using the on_finish function
        function confidence_on_finish_function(data){
          //Get the data object from the last two trials
          var lastTwoDataObjects = jsPsych.data.get().last(2).values();
          //Get the data of the second last data object (the one from the choice trial)
          var choiceTrial = lastTwoDataObjects[0]; //[0] is the choice trial
          //Add in the response of this the confidence trial to choice trial
          choiceTrial.confidenceresponse = data.response;
          choiceTrial.response=data.response; 
        }
		//this function takes the targets and nontargets and makes all possible combos of 2 targets and one nontarget 
		function make_all_RDK_combos(targets, nontargets) //make all combos doesn't work with phase 2 script, so fix that. 
		{

			
			var result=[]; 
			var pairs=[]; 
			for (var i=0; i<targets.length-1; i++)
			{	
			for(var j=i+1;j<targets.length; j++)
			{
				var mini=[]; 
				mini.push(targets[i]); 
				mini.push(targets[j]); 
				pairs.push(mini); 
			}
			}

			
			for(var i=0; i<pairs.length; i++)
			{
				var a=pairs[i][0];
				var b=pairs[i][1];
			
				for(var j=0; j<nontargets.length; j++)
				{
					var c=nontargets[j]; 
					var mini2=[];  
					mini2.push(a); 
					mini2.push(b); 
					mini2.push(c);
					mini2 = jsPsych.randomization.repeat(mini2, 1); 
					result.push(mini2); 
					return result; // remove line!!!
				}
			}
			return result;  
		} 
		
		
	
	///////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////RDK CODE ABOVE THIS LINE////////////////////////////////////////////////////
	
				
	displayData=false; 
	savingLocally=true; 
	
	var random_number= Math.floor(Math.random() * 3) + 1;
	var random_number2=Math.floor(Math.random()*2)+1;
	console.log('random_number');
	console.log(random_number);
	console.log('random number 2');
	console.log(random_number2);
	faces_timeline=[];
	faces_timeline=faces_timeline.concat(faceInstructions1);
	faces_timeline=faces_timeline.concat(faces_phase1);
	faces_timeline=faces_timeline.concat(faces_prepForPhase2);
	faces_timeline=faces_timeline.concat(faceInstructions2);
	faces_timeline=faces_timeline.concat(faces_loopNode);

    timeline=timeline.concat(welcomeInstructions);

	if(random_number===1) //faces and Linecoherence
	{
		if(random_number2===1)
		{
		   timeline=timeline.concat(faces_timeline);
		   timeline=timeline.concat(LineCoherenceInstructions);
           timeline=timeline.concat(LineCoherencetimeline);
		}
		else if(random_number2===2)
		{
			timeline=timeline.concat(LineCoherenceInstructions);
			timeline=timeline.concat(LineCoherencetimeline);
			timeline=timeline.concat(faces_timeline);		
		}
	   //Push the trials into the timeline array
  ;
	}
	else if(random_number===2) //faces and RDK
	{
		if(random_number2===1)
		{
		   timeline=timeline.concat(faces_timeline);
		   timeline=timeline.concat(RDKInstructions);
           timeline=timeline.concat(RDK_timeline);
		}
		else if(random_number2===2)
		{
			timeline=timeline.concat(RDKInstructions);
			timeline=timeline.concat(RDK_timeline);
			timeline=timeline.concat(faces_timeline);		
		}
	   //Push the trials into the timeline array
	}
	else if(random_number===3) //LineCoherence and RDK
	{
		if(random_number2===1)
		{
		   timeline=timeline.concat(RDKInstructions);
		   timeline=timeline.concat(RDK_timeline);
		   timeline=timeline.concat(LineCoherenceInstructions);
           timeline=timeline.concat(LineCoherencetimeline);
		}
		else if(random_number2===2)
		{
			timeline=timeline.concat(LineCoherenceInstructions);
			timeline=timeline.concat(LineCoherencetimeline);
			timeline=timeline.concat(RDKInstructions);
			timeline=timeline.concat(RDK_timeline);		
		}
	   //Push the trials into the timeline array

	}
	  
           //Push the trials into the timeline array
       //     timeline=timeline.concat(faces_phase1);
//            timeline=timeline.concat(faces_prepForPhase2);
//            timeline=timeline.concat(faces_loopNode);
//            //timeline=timeline.concat(faces_phase2Array);
//            timeline=timeline.concat(LineCoherencetimeline);
//            timeline=timeline.concat(RDK_timeline);
       // timeline.push(makeFullscreenBlock());
      //  timeline.push(welcomeInstructions);
        //timeline.push(faces_phase1);
        //timeline.push(faces_prepForPhase2);
   //   timeline.push(faceInstructions1);

   //    timeline.push(faceInstructions2);
  //      timeline.push(surveyBlock);
        //timeline.push(debriefBlock);
        
        
        //timeline.push(LineCoherencetimeline); 
        
        console.log('timeline'); 
        console.log(timeline);
        
        //-----------------Your code above this line-----------------//
        ///////////////////////////////////////////////////////////////


        //---------Run the experiment---------
    
        //Initiate the experiment
        jsPsych.init({
          timeline: timeline,
          on_finish: function(){ //Execute this when the experiment finishes
            if(savingLocally){
              jsPsych.data.get().localSave('csv','testSave.csv'); //Save the data locally in a .csv file
            }
            if(displayData){
              jsPsych.data.displayData(); //Display the data onto the browser screen
            }
            if(psiTurkIsOn){
              psiturk.saveData({ 
                success: function(){
                  //Only submit the HIT if all phases are completed
                  if(allPhasesCompleted){
                    psiturk.completeHIT(); //Complete the HIT
                  }
                }
              });
            }
          },
          on_trial_finish: function(){ //Execute this after every trial
            if (savingToDatabase){
              save_data(tableName, [jsPsych.data.get().last(1).values()[0]]);
            }
          }
        });

        
        //------psiTurk Functions Begin------
    
        //A function to save the data to the SQL table on the psiturk server.  This gets called at the end of the file.
        function save_data(data_table,data){
        
        if(savingLocally){
              jsPsych.data.get().localSave('csv','testSave.csv'); //Save the data locally in a .csv file
              'hello'; 
            }
          
          if(psiTurkIsOn){
            //Retrieve data from psiTurk and add to jsPsych data 
            jsPsych.data.addProperties(
              {
                workerId: psiturk.taskdata.get('workerId'),
                assignmentId: psiturk.taskdata.get('assignmentId'),
                hitId: psiturk.taskdata.get('hitId') 
              }
            );
          }
          //Else psiturk is not on
          else{
            //Get the workerID from the URL and return it
            //Add data to the jsPsych data file
            jsPsych.data.addProperties({
                workerId: workerId,
                assignmentId: assignmentId,
                hitId: hitId
            });
            
          }
          
          
          //Use AJAX to post the data onto the psiturk server
          $.ajax({
            type:'post',
            cache: false,
            url: 'https://psiturk.psych.ucla.edu/~' + username + '/' + folderName + '/templates/savedata.php',
            data: {
              table: data_table,
              json: JSON.stringify(data),
            },
            success: function(output) { console.log(output); } // write the result to javascript console
          });
        }//End of save_data
        
        //------psiTurk Functions End------
        
        
        // Function to draw parameters from the URL
        function $_GET(param) 
        {
            var vars = {};
            window.location.href.replace( 
                /[?&]+([^=&]+)=?([^&]*)?/gi, // regexp
                function( m, key, value ) { // callback
                    vars[key] = value !== undefined ? value : '';
                }
            );

            if ( param ) 
            {
                console.log(vars);
                console.log(param);
                return vars[param] ? vars[param] : null;    
            }
            return vars;
        }



    </script>
</html>